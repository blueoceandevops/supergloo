// Copyright 2018 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

// $title: Authentication Policy
// $description: Authentication policy for Istio services.
// $location: https://istio.io/docs/reference/config/istio.authentication.v1alpha1.html

// This package defines user-facing authentication policy.
package smi.split.v1alpha1;

option go_package = "github.com/solo-io/supergloo/pkg/api/external/smi/split/v1alpha1";

import "github.com/solo-io/solo-kit/api/v1/metadata.proto";
import "github.com/solo-io/solo-kit/api/v1/solo-kit.proto";
import "gogoproto/gogo.proto";
option (gogoproto.equal_all) = true;

// TrafficTarget associates a set of traffic definitions (rules) with a service identity which is allocated to a group of pods.
// Access is controlled via referenced TrafficSpecs and by a list of source service identities.
// * If a pod which holds the referenced service identity makes a call to the destination on one of the defined routes then access
//   will be allowed
// * Any pod which attempts to connect and is not in the defined list of sources will be denied
// * Any pod which is in the defined list, but attempts to connect on a route which is not in the list of the
//   TrafficSpecs will be denied
message TrafficSplit {
    option (core.solo.io.resource).short_name = "ts";
    option (core.solo.io.resource).plural_name = "trafficsplits";

    // Metadata contains the object metadata for this resource
    core.solo.io.Metadata metadata = 101 [(gogoproto.nullable) = false];

    // Specification of the desired behavior of the traffic split.
    // More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
    TrafficSplitSpec spec = 1;
}

// TrafficSplitSpec is the specification for a TrafficSplit
message TrafficSplitSpec {
    string service = 1;
    repeated TrafficSplitBackend backends = 2;
}

// TrafficSplitBackend defines a backend
message TrafficSplitBackend {
    string service = 1;
    Quantity weight = 2;
}

// Quantity is a fixed-point representation of a number.
// It provides convenient marshaling/unmarshaling in JSON and YAML,
// in addition to String() and Int64() accessors.
//
// The serialization format is:
//
// <quantity>        ::= <signedNumber><suffix>
//   (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
// <digit>           ::= 0 | 1 | ... | 9
// <digits>          ::= <digit> | <digit><digits>
// <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits>
// <sign>            ::= "+" | "-"
// <signedNumber>    ::= <number> | <sign><number>
// <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI>
// <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
//   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
// <decimalSI>       ::= m | "" | k | M | G | T | P | E
//   (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
// <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>
//
// No matter which of the three exponent forms is used, no quantity may represent
// a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal
// places. Numbers larger or more precise will be capped or rounded up.
// (E.g.: 0.1m will rounded up to 1m.)
// This may be extended in the future if we require larger or smaller quantities.
//
// When a Quantity is parsed from a string, it will remember the type of suffix
// it had, and will use the same type again when it is serialized.
//
// Before serializing, Quantity will be put in "canonical form".
// This means that Exponent/suffix will be adjusted up or down (with a
// corresponding increase or decrease in Mantissa) such that:
//   a. No precision is lost
//   b. No fractional digits will be emitted
//   c. The exponent (or suffix) is as large as possible.
// The sign will be omitted unless the number is negative.
//
// Examples:
//   1.5 will be serialized as "1500m"
//   1.5Gi will be serialized as "1536Mi"
//
// Note that the quantity will NEVER be internally represented by a
// floating point number. That is the whole point of this exercise.
//
// Non-canonical values will still parse as long as they are well formed,
// but will be re-emitted in their canonical form. (So always use canonical
// form, or don't diff.)
//
// This format is intended to make it difficult to use these numbers without
// writing some sort of special handling code in the hopes that that will
// cause implementors to also use a fixed point implementation.
message Quantity {
    string string = 1;
}

